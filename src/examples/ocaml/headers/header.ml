(* Generated by re2ocaml *)
(* re2ocaml $INPUT -o $OUTPUT --header lexer/state.ml -i *)

open State
open String




let rec yy0 (yyrecord : State.state) : int =
    let yych = unsafe_get yyrecord.yyinput yyrecord.yycursor in
    match yych with
        | 'a' ->
            yyrecord.yycursor <- yyrecord.yycursor + 1;
            (yy0 [@tailcall]) yyrecord
        | 'b' ->
            yyrecord.yyt1 <- yyrecord.yycursor;
            yyrecord.yycursor <- yyrecord.yycursor + 1;
            (yy2 [@tailcall]) yyrecord
        | _ ->
            yyrecord.yyt1 <- yyrecord.yycursor;
            (yy1 [@tailcall]) yyrecord

and yy1 (yyrecord : State.state) : int =
    yyrecord.tag <- yyrecord.yyt1;
    yyrecord.tag

and yy2 (yyrecord : State.state) : int =
    let yych = unsafe_get yyrecord.yyinput yyrecord.yycursor in
    match yych with
        | 'b' ->
            yyrecord.yycursor <- yyrecord.yycursor + 1;
            (yy2 [@tailcall]) yyrecord
        | _ -> (yy1 [@tailcall]) yyrecord

and lex (yyrecord : State.state) : int =
    (yy0 [@tailcall]) yyrecord



let main () =
    let st = {
        yyinput = "ab";
        yycursor = 0;
        tag = 0;
        
	yyt1 = 0;
    }
    in if not (lex st = 1) then raise (Failure "error")

let _ = main ()
(* Generated by re2ocaml *)

type state = {
    yyinput: string;
    mutable yycursor: int;
    mutable tag: int;
    mutable yyt1: int;
}
ocaml/headers/header.re:21:19: warning: rule matches empty string [-Wmatch-empty-string]
